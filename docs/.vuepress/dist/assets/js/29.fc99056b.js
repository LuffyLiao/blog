(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{539:function(v,_,t){"use strict";t.r(_);var e=t(6),a=Object(e.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h3",{attrs:{id:"前言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[v._v("#")]),v._v(" 前言")]),v._v(" "),t("p",[v._v("众所周知，javscript是"),t("code",[v._v("单线程")]),v._v("，但是为什么单线程又有"),t("code",[v._v("异步")]),v._v("的能力。本文从"),t("code",[v._v("线程")]),v._v("、"),t("code",[v._v("进程")]),v._v("的角度来解释这个问题。")]),v._v(" "),t("h3",{attrs:{id:"cpu"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cpu"}},[v._v("#")]),v._v(" CPU")]),v._v(" "),t("p",[v._v("计算机的核心是CPU，计算机所有的计算都是由它负责。它就像一座工厂，时刻在运行。")]),v._v(" "),t("h3",{attrs:{id:"进程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#进程"}},[v._v("#")]),v._v(" 进程")]),v._v(" "),t("p",[v._v("工厂的电力有限，一次只能供给一个车间使用。每次车间开工的时候，其他车间必须停工。即单个CPU一次只能运行一个任务。")]),v._v(" "),t("p",[t("code",[v._v("进程")]),v._v("就像是工厂的车间，它代表CPU所能处理的单个任务。"),t("code",[v._v("进程")]),v._v("之间相互独立，任意时刻，CPU总是运行一个"),t("code",[v._v("进程")]),v._v("，CPU通过时间片轮转法来实现同时运行多个"),t("code",[v._v("进程")])]),v._v(" "),t("h3",{attrs:{id:"线程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程"}},[v._v("#")]),v._v(" 线程")]),v._v(" "),t("p",[v._v("每个车间，都可以有很多工人，共享车间的资源，他们协同完成一个任务。")]),v._v(" "),t("p",[t("code",[v._v("线程")]),v._v("就好比车间里的工人，一个"),t("code",[v._v("进程")]),v._v("可以包括多个"),t("code",[v._v("线程")]),v._v("，多个"),t("code",[v._v("线程")]),v._v("共享"),t("code",[v._v("进程")]),v._v("资源。")]),v._v(" "),t("h3",{attrs:{id:"cpu、进程、线程之间的关系"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cpu、进程、线程之间的关系"}},[v._v("#")]),v._v(" CPU、进程、线程之间的关系")]),v._v(" "),t("ul",[t("li",[t("code",[v._v("进程")]),v._v("是cpu资源分配的最小单位，每个应用程序就是一个"),t("code",[v._v("进程")])]),v._v(" "),t("li",[t("code",[v._v("线程")]),v._v("是cpu调度的最小单位")]),v._v(" "),t("li",[v._v("不同"),t("code",[v._v("进程")]),v._v("之间也可以通信，但是相对复杂")]),v._v(" "),t("li",[t("code",[v._v("单线程")]),v._v("和"),t("code",[v._v("多线程")]),v._v("是指在一个"),t("code",[v._v("进程")]),v._v("内的单和多")])]),v._v(" "),t("h3",{attrs:{id:"浏览器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浏览器"}},[v._v("#")]),v._v(" 浏览器")]),v._v(" "),t("p",[v._v("当我们在浏览器打开多个tab时，打开控制管理器，可以看到一个谷歌浏览器启动了多个进程。所以大致可以知道，浏览器时多进程的，每个tab页就是个独立的进程。")]),v._v(" "),t("h3",{attrs:{id:"浏览器的渲染进程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浏览器的渲染进程"}},[v._v("#")]),v._v(" 浏览器的渲染进程")]),v._v(" "),t("p",[v._v("浏览器的渲染进程也包括多个线程")]),v._v(" "),t("ul",[t("li",[t("code",[v._v("GUI渲染线程")]),v._v(" "),t("ul",[t("li",[v._v("负责渲染页面，布局和绘制")]),v._v(" "),t("li",[v._v("页面需要重绘和回流时，该线程就会执行")]),v._v(" "),t("li",[v._v("与js引擎线程互斥，防止渲染结果不可预期")])])]),v._v(" "),t("li",[t("code",[v._v("JS引擎线程")]),v._v(" "),t("ul",[t("li",[v._v("负责处理解析和执行JavaScript脚本程序")]),v._v(" "),t("li",[v._v("只有一个JS引擎线程（单线程）")]),v._v(" "),t("li",[v._v("与GUI渲染线程互斥，防止渲染结果不可预期")])])]),v._v(" "),t("li",[t("code",[v._v("事件触发线程")]),v._v(" "),t("ul",[t("li",[v._v("用来控制事件循环，鼠标点击，setTimeout，ajax等")]),v._v(" "),t("li",[v._v("当事件满足触发条件时，将事件放入到JS引擎所在的执行队列中")])])]),v._v(" "),t("li",[t("code",[v._v("定时触发器线程")]),v._v(" "),t("ul",[t("li",[v._v("setInterval与setTimeout所在线程")]),v._v(" "),t("li",[v._v("计时完毕后，通知事件触发线程")])])]),v._v(" "),t("li",[t("code",[v._v("异步http请求线程")]),v._v(" "),t("ul",[t("li",[v._v("浏览器有个单独的线程用来处理ajax请求")]),v._v(" "),t("li",[v._v("请求完成时，若有回调函数，通知事件触发线程")])])])]),v._v(" "),t("p",[v._v("当了解以上渲染进程包含的这些线程后，我们就可以知道：")]),v._v(" "),t("ol",[t("li",[v._v("为什么JavaScript要设计成单线程的")]),v._v(" "),t("li",[v._v("为什么GUI渲染线程与JS引擎线程互斥")])]),v._v(" "),t("h3",{attrs:{id:"为什么javascript要设计成单线程的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么javascript要设计成单线程的"}},[v._v("#")]),v._v(" 为什么JavaScript要设计成单线程的")]),v._v(" "),t("ol",[t("li",[v._v("多线程操作需要加锁，编码的复杂性更高")]),v._v(" "),t("li",[v._v("JavaScript最初是解决用户交互的，如果同时操作DOM。在多线程不加锁的情况下，最终会导致DOM的渲染结果不可预期")])]),v._v(" "),t("h3",{attrs:{id:"为什么gui渲染线程与js引擎线程互斥"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么gui渲染线程与js引擎线程互斥"}},[v._v("#")]),v._v(" 为什么GUI渲染线程与JS引擎线程互斥")]),v._v(" "),t("p",[v._v("JavaScript可以操作DOM元素，如果同时修改元素属性，并同时渲染界面，那么最终可能导致前后获得的元素不一致。\n所以当"),t("code",[v._v("JS引擎线程")]),v._v("执行时，"),t("code",[v._v("GUI渲染线程")]),v._v("会被挂起，GUI更新则会保存在一个队列中，等待"),t("code",[v._v("JS引擎线程")]),v._v("空闲时间立即被执行。")]),v._v(" "),t("h3",{attrs:{id:"event-loop"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#event-loop"}},[v._v("#")]),v._v(" Event Loop")]),v._v(" "),t("p",[v._v("先了解一些概念：")]),v._v(" "),t("ul",[t("li",[v._v("JS分为同步任务和异步任务")]),v._v(" "),t("li",[v._v("同步任务都在JS引擎线程上执行，形成一个"),t("code",[v._v("执行栈")])]),v._v(" "),t("li",[v._v("事件触发线程管理一个"),t("code",[v._v("任务对列")]),v._v("，异步任务触发条件达成，将回调事件放到"),t("code",[v._v("任务对列")]),v._v("中")]),v._v(" "),t("li",[t("code",[v._v("执行栈")]),v._v("中所有的同步任务执行完毕，此时JS引擎线程空闲，系统会读取"),t("code",[v._v("任务对列")]),v._v("，将可运行的异步任务回调事件添加到"),t("code",[v._v("执行栈")]),v._v("中，开始执行")])]),v._v(" "),t("p",[v._v("前端开发中我们通过"),t("code",[v._v("setTimeout/setInterval")]),v._v("和"),t("code",[v._v("XHR/fetch")]),v._v("发送网络请求，其实不管是"),t("code",[v._v("setTimeout/setInterval")]),v._v("还是"),t("code",[v._v("XHR/fetch")]),v._v("。这些代码被执行时，本身是同步任务，而其中的回调函数才是异步任务。")]),v._v(" "),t("p",[v._v("当代码执行到"),t("code",[v._v("setTimeout/setInterval")]),v._v("时，"),t("code",[v._v("JS引擎线程")]),v._v("通知"),t("code",[v._v("定时器触发线程")]),v._v("，间隔一段时间后会触发一个回调事件，而"),t("code",[v._v("定时器触发线程")]),v._v("在接收到这个消息后，并在等待时间后，将回调事件放入到由"),t("code",[v._v("事件触发线程")]),v._v("所管理的"),t("code",[v._v("事件对列")]),v._v("中。")]),v._v(" "),t("p",[v._v("当代码执行到"),t("code",[v._v("XHR/fetch")]),v._v("时，"),t("code",[v._v("JS引擎线程")]),v._v("通知"),t("code",[v._v("异步http请求线程")]),v._v("，发送一个网络请求，并制定请求完成的回调事件。而"),t("code",[v._v("异步http请求线程")]),v._v("在接收到这个消息后，会在请求成功后，将回调事件放入到由"),t("code",[v._v("事件触发线程")]),v._v("所管理的"),t("code",[v._v("事件对列")]),v._v("中。")]),v._v(" "),t("p",[v._v("当我们的同步任务执行完，"),t("code",[v._v("JS引擎线程")]),v._v("会询问"),t("code",[v._v("事件触发线程")]),v._v("，在事件对列中是否有待执行的回调函数，如果有就加入到执行栈中交给"),t("code",[v._v("JS引擎线程")]),v._v("执行")]),v._v(" "),t("p",[v._v("有点长，总结一下：")]),v._v(" "),t("ul",[t("li",[v._v("JS引擎线程只执行"),t("code",[v._v("执行栈")]),v._v("中的事件")]),v._v(" "),t("li",[v._v("执行栈中的代码执行完毕，就读取事件对列中的事件")]),v._v(" "),t("li",[v._v("事件对列中的回调事件，是由各自线程插入到事件对列中的")])]),v._v(" "),t("h3",{attrs:{id:"宏任务、微任务"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#宏任务、微任务"}},[v._v("#")]),v._v(" 宏任务、微任务")]),v._v(" "),t("h4",{attrs:{id:"什么是宏任务"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是宏任务"}},[v._v("#")]),v._v(" 什么是宏任务")]),v._v(" "),t("p",[v._v("我们可以将每次执行栈执行的代码当做是一个宏任务(包括每次从事件对列中获取一个事件并放到执行栈中执行)，每一个宏任务会从到到尾执行完毕。")]),v._v(" "),t("p",[v._v("我们前文提到过的"),t("code",[v._v("JS引擎线程")]),v._v("和"),t("code",[v._v("GUI渲染线程")]),v._v("是互斥关系，浏览器为了能够使宏任务和DOM任务有序进行，会在一个宏任务执行结果后，在下一个宏任务执行💰，"),t("code",[v._v("GUI渲染线程")]),v._v("开始工作，渲染页面")]),v._v(" "),t("p",[v._v("宏任务 => 渲染 => 宏任务 => 渲染 => 渲染 ....")]),v._v(" "),t("p",[v._v("主代码块，setTimeout，setInterval等，都属于宏任务")]),v._v(" "),t("h3",{attrs:{id:"什么是微任务"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是微任务"}},[v._v("#")]),v._v(" 什么是微任务")]),v._v(" "),t("p",[v._v("我们知道了宏任务结束后，会执行渲染，然后执行下一个微任务，而微任务可以理解成当前宏任务执行后立即执行的任务。")]),v._v(" "),t("p",[v._v("也就是说，当宏任务执行完，会在渲染前，将执行期间所产生的所有微任务都执行完。Promise，process.nextTick等，都是微任务。")]),v._v(" "),t("h3",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[v._v("#")]),v._v(" 总结")]),v._v(" "),t("ul",[t("li",[v._v("执行一个宏任务，栈中没有就从事件对列中获取")]),v._v(" "),t("li",[v._v("执行过程中如果遇到微任务，就将它添加到微任务对列中")]),v._v(" "),t("li",[v._v("宏任务执行完毕后，立即依次执行当前微任务对列中的所有微任务")]),v._v(" "),t("li",[v._v("当前宏任务执行完毕，开始检查渲染，然后GUI线程渲染")]),v._v(" "),t("li",[v._v("渲染完毕后，JS线程继续接管，开始下个宏任务")])])])}),[],!1,null,null,null);_.default=a.exports}}]);