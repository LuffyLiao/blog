(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{538:function(v,_,t){"use strict";t.r(_);var l=t(6),i=Object(l.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h3",{attrs:{id:"this到底指向谁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#this到底指向谁"}},[v._v("#")]),v._v(" this到底指向谁")]),v._v(" "),t("p",[t("strong",[v._v("谁调用就指向谁")])]),v._v(" "),t("ul",[t("li",[v._v("严格模式下，函数内的this会被绑定到undefined上，非严格模式则会被绑定到全局对象window/global上")]),v._v(" "),t("li",[v._v("一般使用new 构造函数时，构造函数内的this会被绑定到新创建的对象上")]),v._v(" "),t("li",[v._v("一般通过call/bind/apply方法显式调用时，函数内的this会被绑定到指定的参数对象上")]),v._v(" "),t("li",[v._v("箭头函数的this是由外层作用域决定")])]),v._v(" "),t("h3",{attrs:{id:"js代码执行的两个阶段"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#js代码执行的两个阶段"}},[v._v("#")]),v._v(" js代码执行的两个阶段")]),v._v(" "),t("ul",[t("li",[v._v("代码预编译阶段")]),v._v(" "),t("li",[v._v("代码执行阶段")])]),v._v(" "),t("p",[v._v("JavaScript是解释型语言，编译一行，执行一行。但是在代码执行前，JavaScript引擎会做一些预准备工作。")]),v._v(" "),t("ol",[t("li",[v._v("进行变量声明")]),v._v(" "),t("li",[v._v("对变量声明进行提升，但是值为undefined")]),v._v(" "),t("li",[v._v("函数声明提升\n代码执行的整个过程就是一条生产流水线。第一道工序是在预编译阶段创建变量对象VO(Veriable Object)，此时只是创建，而未进行赋值。到了下一道工序代码执行阶段，变量对象会转为激活对象AO(Active Object)，既完成VO到AO的转换，此时作用域会被确定。")])]),v._v(" "),t("h3",{attrs:{id:"内存管理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内存管理"}},[v._v("#")]),v._v(" 内存管理")]),v._v(" "),t("ol",[t("li",[v._v("基本概念")])]),v._v(" "),t("ul",[t("li",[v._v("栈：由操作系统自动分配，存放的是原始数据类型")]),v._v(" "),t("li",[v._v("堆：由开发者分配释放，这部分要考虑垃圾回收的问题，一般存放的是引用类型的地址")])]),v._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[v._v("垃圾回收")])]),v._v(" "),t("ul",[t("li",[v._v("引用计数 计算引用的次数")]),v._v(" "),t("li",[v._v("标记清除 使用了一次就标记一次")])]),v._v(" "),t("h3",{attrs:{id:"输入url-全过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#输入url-全过程"}},[v._v("#")]),v._v(" 输入url 全过程")]),v._v(" "),t("ol",[t("li",[v._v("解析url，根据dns系统进行ip查找\n"),t("ul",[t("li",[v._v("先查找host文件是否有设置，有的话就会把对应的ip映射返回")]),v._v(" "),t("li",[v._v("如果host没有，则去查找本地dns服务器有没有缓存，有则返回")]),v._v(" "),t("li",[v._v("根dns服务器上查找")])])]),v._v(" "),t("li",[v._v("tcp三次握手\n"),t("ul",[t("li",[v._v("主机A发送请求建立连接")]),v._v(" "),t("li",[v._v("主机B收到，向A发送确认号")]),v._v(" "),t("li",[v._v("主机A收到，检查确认号，主机A再次发送确认号，主机B收到确认，建立连接")])])]),v._v(" "),t("li",[v._v("请求html文件，如果文件在缓存，则直接返回，没有就从后台拿\n"),t("ul",[t("li",[v._v("构建dom树，从上到下解析html文档生成dom节点")]),v._v(" "),t("li",[v._v("构建cssom树，加载解析样式生成cssom树")]),v._v(" "),t("li",[v._v("执行JavaScript")]),v._v(" "),t("li",[v._v("构建渲染树，根据dom树和cssom树，生成渲染树")]),v._v(" "),t("li",[v._v("布局，根据渲染树将节点树的每一个节点布局在屏幕上的正确位置")]),v._v(" "),t("li",[v._v("绘制，遍历渲染树绘制所有节点")])])])]),v._v(" "),t("h3",{attrs:{id:"http-https-http2-0"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http-https-http2-0"}},[v._v("#")]),v._v(" http https http2.0")]),v._v(" "),t("ol",[t("li",[v._v("http：超文本传输协议\n"),t("ul",[t("li",[v._v("请求报文：请求行（method version）、请求头、请求数据、url、policy")]),v._v(" "),t("li",[v._v("响应报文：状态行 keep-alive 、user-agent")])])]),v._v(" "),t("li",[v._v("tcp/udp\n"),t("ul",[t("li",[v._v("tcp：面向连接的协议，类似打电话，需要确认身份")]),v._v(" "),t("li",[v._v("udp：面向无连接的协议，类似广播")])])]),v._v(" "),t("li",[v._v("https\n"),t("ul",[t("li",[v._v("https就是从http加上加密处理 + 认证 + 完整性保护")]),v._v(" "),t("li",[v._v("区别： 加密 + 安全性")])])]),v._v(" "),t("li",[v._v("http2\n"),t("ul",[t("li",[v._v("多路复用：即共享连接，每个request对应一个id，共享机制，这样一个连接上可以有多个request，接收方根据request的id用作区分")]),v._v(" "),t("li",[v._v("二进制分帧")])])]),v._v(" "),t("li",[v._v("状态码\n"),t("ul",[t("li",[v._v("2XX：成功 200")]),v._v(" "),t("li",[v._v("3XX：重定向 302：临时重定向 301：永久重定向")]),v._v(" "),t("li",[v._v("4XX：客户端错误 404 not found")]),v._v(" "),t("li",[v._v("5XX：服务端错误 500")])])])]),v._v(" "),t("h3",{attrs:{id:"webpack"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack"}},[v._v("#")]),v._v(" webpack")]),v._v(" "),t("ol",[t("li",[v._v("webpack的作用：\n"),t("ul",[t("li",[v._v("模块打包，将不同模块的文件打包整合在一起")]),v._v(" "),t("li",[v._v("编译兼容，编译转换.less,.vue,.jsx,es6这类在浏览器无法识别的文件")]),v._v(" "),t("li",[v._v("能力扩展，比如按需加载，代码压缩")])])]),v._v(" "),t("li",[v._v("模块打包的原理\n"),t("ul",[t("li",[v._v("读取webpack配置参数")]),v._v(" "),t("li",[v._v("启动webpack，创建compiler对象并解析项目")]),v._v(" "),t("li",[v._v("从入口文件entry解析，找到依赖模块，递归遍历分析，形成依赖关系树")]),v._v(" "),t("li",[v._v("对不同文件类型的依赖模块文件使用对应的loader进行编译，转成js文件")]),v._v(" "),t("li",[v._v("最终生成的是一个IIFE自执行函数")])])]),v._v(" "),t("li",[v._v("sourceMap\nsourceMap是一项将编译、打包、压缩后的代码映射回源代码的技术，由于打包压缩后的代码并没有阅读性可言，一旦在开发中报错或者遇到问题，直接在混淆代码中debug问题会带来非常糟糕的体验，sourceMap可以帮助我们快速定位到源代码的位置，提高我们的开发效率。一般在开发环境配置，线上关闭。")]),v._v(" "),t("li",[v._v("Loader: 对非js文件的转换，所以思路应该是通过正则匹配到对应的文件，然后进行转换，最终返回一个js的字符串。目前生态已经可以满足日常需求，想不出还有什么场景需要自己去写loader。")]),v._v(" "),t("li",[v._v("Plugin: 写过，举一个简单的路径替换的例子\n"),t("ul",[t("li",[v._v("在plug目录下创建一个js文件")]),v._v(" "),t("li",[v._v("因为需要访问compiler对象，所以plug中必须是一个函数或者一个包含apply方法的对象")]),v._v(" "),t("li",[v._v("遍历所有的资源文件，匹配到符合条件的文件，进行正则替换")]),v._v(" "),t("li",[v._v("webpack配置new CssPath")])])])]),v._v(" "),t("h3",{attrs:{id:"数据类型的判断"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据类型的判断"}},[v._v("#")]),v._v(" 数据类型的判断")]),v._v(" "),t("ol",[t("li",[v._v("typeof：只能判断原始数据类型，对引用类型的话不准确")]),v._v(" "),t("li",[v._v("constructor：查看目标的构造函数，但是null和undefined 会报错，而且这个可以人为手动修改，不准确")]),v._v(" "),t("li",[v._v("instanceof：a instanceof A，a是否为A的实例，即a的原型链上是否存在A的构造函数")]),v._v(" "),t("li",[v._v("Object.prototype.toString.call()：万能的方法，任何Object原型都有toString方法")])]),v._v(" "),t("h3",{attrs:{id:"原型链"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原型链"}},[v._v("#")]),v._v(" 原型链")]),v._v(" "),t("p",[v._v("原型指的就是一个对象，实例继承那个对象的属性。在原型上定义的属性，通过继承，实例也有这个属性。\n原型链就是一个过程，原型是原型链这个过程中的一个单位，贯穿整个原型链，比如一个new一个Object，由他实例化的fn的__proto__ -> constructor 指向Object，而Object")]),v._v(" "),t("h3",{attrs:{id:"vue-和-react的区别-都是mvvm框架-数据更新视图"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-和-react的区别-都是mvvm框架-数据更新视图"}},[v._v("#")]),v._v(" vue 和 react的区别 ，都是MVVM框架，数据更新视图")]),v._v(" "),t("ol",[t("li",[v._v("监听数据变化的实现原理不同\n"),t("ul",[t("li",[v._v("vue : Object.property getter setter 劫持数据，能精确知道数据的变化，使用的是可变数据")]),v._v(" "),t("li",[v._v("react: React 默认是通过比较引用的方式进行的，更强调数据的不可变性")])])]),v._v(" "),t("li",[v._v("数据流不同\n"),t("ul",[t("li",[v._v("vue: parent -> child <-> dom，")]),v._v(" "),t("li",[v._v("react: parent -> child -> dom，单向数据流")])])]),v._v(" "),t("li",[v._v("混入方式\n"),t("ul",[t("li",[v._v("vue: mixins")]),v._v(" "),t("li",[v._v("react: HoC(高阶组件)：一个函数接受一个组件作为参数，经过加工，返回一个新组件。")])])]),v._v(" "),t("li",[v._v("模板渲染方式：\n"),t("ul",[t("li",[v._v("vue: html")]),v._v(" "),t("li",[v._v("react: jsx渲染模板，功能强大，灵活性强")])])]),v._v(" "),t("li",[v._v("anuglar: MVC框架")])]),v._v(" "),t("h3",{attrs:{id:"react-hooks"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#react-hooks"}},[v._v("#")]),v._v(" react hooks")]),v._v(" "),t("p",[v._v("react都核心思想就是，将一个页面拆成一堆独立的，可复用的组件，并且用自上而下的单向数据流的形式将这些组件串联起来。\nhooks 本质就是一类特殊的函数，他们可以为你的函数型组件注入一些特殊功能，不用再写很难维护的class。让function一统江湖")])])}),[],!1,null,null,null);_.default=i.exports}}]);